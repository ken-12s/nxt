<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta
  name="viewport"
  content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover"
/>
<title>Iso Grid Builder</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Nanum+Gothic:wght@400;600;700&display=swap');
  :root{
    --bg:#1f2432;--panel:#2b3146;--muted:#9aa3be;
    --tile-a:#e9edf5;--tile-b:#dfe5f0;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:#eef1fb;font-family:"Nanum Gothic","Noto Sans KR",system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif}
  /* 모바일 안전 뷰포트: 우선 svh, 지원되면 dvh로 덮어쓰기 */
  .app{
    display:grid;grid-template-rows:auto auto 1fr;
    height:100svh; /* 모바일 주소창 높이 변화 대응 */
    min-height:0;  /* grid child overflow 방지 */
  }
  @supports (height: 100dvh){
    .app{height:100dvh}
  }

  .bar{display:flex;gap:12px;align-items:center;padding:10px 14px;background:#2b3146;border-bottom:1px solid #0004;flex-wrap:wrap;min-height:0}
  .seg{display:inline-flex;border:1px solid #0006;background:#0003;border-radius:12px;overflow:hidden}
  .seg label{cursor:pointer;padding:7px 12px;border-right:1px solid #0005;font-size:13px;color:#dfe5ff;user-select:none;transition:.15s}
  .seg label:last-child{border-right:0}
  .seg input{display:none}
  .seg input:checked+span{background:#3b82f655;color:#fff;box-shadow:0 0 0 2px #60a5fa inset,0 2px 10px #0006;text-shadow:0 1px 0 #0008}
  .btn{
    padding:7px 10px;border:1px solid #0005;background:#0003;border-radius:10px;
    cursor:pointer;font-size:13px;color:#dfe5ff;
    display:inline-flex;align-items:center;justify-content:center;white-space:nowrap;line-height:1;
  }
  .btn:active{transform:translateY(1px)}
  .form{
    display:flex; gap:10px; align-items:center; padding:8px 14px;
    background:#22283a; border-bottom:1px solid #0004;
    flex-wrap:nowrap;            /* 한 줄 유지 */
    overflow-x:auto; overflow-y:hidden;
    -webkit-overflow-scrolling:touch; /* 모바일 부드러운 스크롤 */
    scrollbar-width:none;        /* Firefox 스크롤바 숨김 */
    min-height:0;
  }
  .form::-webkit-scrollbar{display:none;} /* Chrome/Safari 스크롤바 숨김 */
  .form .field{
    display:flex; align-items:center; gap:6px;
    white-space:nowrap;
    flex-shrink:0;  /* 줄어들지 않고 스크롤 */
  }

  /* 속성/선택 라벨도 줄바꿈 없이 고정 */
  .form .pill{
    flex-shrink:0;
    white-space:nowrap;
  }
  .form input[type="text"]{height:28px;border-radius:8px;border:1px solid #0006;background:#101524;color:#fff;padding:0 8px;min-width:160px}

  /* 캔버스가 grid 안에서 1fr 영역을 제대로 차지하도록 */
  canvas{
    display:block;
    width:100%;
    height:100%;
    min-width:0;   /* grid 아이템 축소 허용 */
    min-height:0;  /* grid 아이템 축소 허용 */
    background:#273048;
    cursor:crosshair;
    touch-action:none;
  }

  .desktop-only{display:inline-flex}
  .mobile-only{display:none}
  @media (max-width: 760px){
    .desktop-only{display:none}
    .mobile-only{display:inline-flex}
    .form{gap:8px}
    #selInfo{max-width:50vw}
  }

  details.menu{position:relative}
  details.menu summary{list-style:none}
  details.menu[open] summary::marker{display:none}
  details.menu .dropdown{
    position:absolute;top:36px;left:0;z-index:20;
    display:flex;flex-direction:column;gap:6px;
    background:#141a2c;border:1px solid #0006;border-radius:10px;padding:10px;min-width:180px;
  }
  details.menu .dropdown button.btn,
  details.menu .dropdown label.btn {
    display:block;
    width:100%;
    text-align:center;
    box-sizing:border-box;
  }

  .pill{padding:2px 6px;border-radius:999px;background:#00000033;border:1px solid #0005;font-size:12px}
  input[type="file"]{display:none}
</style>
</head>
<body>
<div class="app">
  <div class="bar">
    <div class="seg" id="modeSeg">
      <label><input type="radio" name="mode" value="select" checked><span>선택</span></label>
      <label><input type="radio" name="mode" value="build"><span>배치</span></label>
      <label><input type="radio" name="mode" value="erase"><span>지우개</span></label>
    </div>

    <div class="seg" id="sizeSeg">
      <label><input type="radio" name="size" value="1" checked><span>1×1</span></label>
      <label><input type="radio" name="size" value="2"><span>2×2</span></label>
      <label><input type="radio" name="size" value="3"><span>3×3</span></label>
      <label><input type="radio" name="size" value="12"><span>12×12</span></label>
    </div>

    <div class="seg" id="typeSeg" style="margin-left:6px"></div>

    <div class="desktop-only" style="gap:8px;align-items:center">
      <button class="btn" id="saveLocal">배치 저장</button>
      <button class="btn" id="loadLocal">배치 불러오기</button>
      <button class="btn" id="exportJson">JSON 내보내기</button>
      <label class="btn" for="importFile">JSON 가져오기</label>
      <input id="importFile" type="file" accept="application/json" />
    </div>

    <details class="menu mobile-only">
      <summary class="btn">메뉴</summary>
      <div class="dropdown">
        <button class="btn" id="m_saveLocal">배치 저장</button>
        <button class="btn" id="m_loadLocal">배치 불러오기</button>
        <button class="btn" id="m_exportJson">JSON 내보내기</button>
        <label class="btn" for="m_importFile">JSON 가져오기</label>
        <input id="m_importFile" type="file" accept="application/json" />
      </div>
    </details>
  </div>

  <div class="form" id="propForm">
    <span class="pill" id="propTitle">속성</span>
    <div class="field" id="cityNameField"><label>캐릭터명</label><input id="cityCharName" type="text" /></div>
    <div class="field" id="cityIdField"><label>캐릭터ID</label><input id="cityCharId" type="text" /></div>
    <div class="field" id="bearDescField" style="display:none"><label>설명</label><input id="bearDesc" type="text" /></div>
    <div class="field" id="bearKSTField" style="display:none"><label>KST</label><input id="bearKST" type="text" /></div>
    <div class="field" id="bearUTCField" style="display:none"><label>UTC</label><input id="bearUTC" type="text" /></div>
    <div class="field" id="nameOnlyField" style="display:none"><label>이름</label><span id="nameOnlyText"></span></div>
    <span id="selInfo" class="pill"></span>
  </div>

  <canvas id="view"></canvas>
</div>

<script>
(() => {
  // ===== 기본 설정/상수 =====
  const BASE_GRID_W=28, BASE_GRID_H=14;
  const COLS=60, ROWS=60;
  const OUTLINE_PAD=0.40, OBJECT_PAD=0.08;
  const BANNER_R=3, HQ_R=6, CASTLE_R=8;
  const ZOOM_MIN=0.30, ZOOM_MAX=2.0, ZOOM_STEP=0.1;

  const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
  const canvas = document.getElementById('view');
  const ctx = canvas.getContext('2d', {alpha:false});
  //const DPR = isMobile ? 1 : Math.max(1, Math.floor(devicePixelRatio||1));
  const DPR = Math.min(3, Math.ceil(devicePixelRatio || 1));
  ctx.imageSmoothingEnabled = false;

  // 카메라/상태
  let scale=0.9, originX=0, originY=120;
  let isPanning=false, panStart=null, originStart=null;
  let draggingObjId=0, dragObjOffset={dx:0,dy:0}, dragLastPos={gx:0,gy:0};
  let placingDrag=null;
  const activePointers=new Map();
  let pinchStartDist=0, pinchStartScale=1, pinchCenterScreen={x:0,y:0};

  // 포인터 상호작용 중 좌표 기준 고정
  let interactionRect=null;

  // 지우개 드래그 상태
  let isErasing=false;
  let lastErasedCell=null; // {x,y}

  // 유틸
  const GRID_W=()=>BASE_GRID_W*scale, GRID_H=()=>BASE_GRID_H*scale;
  const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
  const gridToScreen=(gx,gy)=>({ x:originX+(gx-gy)*GRID_W(), y:originY+(gx+gy)*GRID_H() });
  function screenToGrid(sx,sy){ const a=(sx-originX)/GRID_W(), b=(sy-originY)/GRID_H(); return { gx:(a+b)/2, gy:(b-a)/2 }; }
  const typeName=(t)=>({banner:'깃발',city:'도시',ally_res:'연맹자원',bear1:'곰사냥터1',bear2:'곰사냥터2',ally_hq:'연맹본부',castle:'캐슬'})[t]||t;
  function css(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
  function radioVal(name){ return (document.querySelector(`input[name="${name}"]:checked`)||{}).value; }
  const inBounds=(x,y)=>x>=0&&y>=0&&x<COLS&&y<ROWS;

  // 현재 상호작용 동안 사용할 로컬 좌표 헬퍼
  function getLocalXY(e){
    const r = interactionRect || canvas.getBoundingClientRect();
    return { sx: e.clientX - r.left, sy: e.clientY - r.top, rect: r };
  }

  // 데이터
  const cells=Array.from({length:ROWS},()=>Array(COLS).fill(0));
  const objects=new Map(); let nextId=1, selectedId=0;

  // UI
  const modeSeg=document.getElementById('modeSeg');
  const sizeSeg=document.getElementById('sizeSeg');
  const typeSeg=document.getElementById('typeSeg');
  const propTitle=document.getElementById('propTitle');
  const cityCharName=document.getElementById('cityCharName');
  const cityCharId=document.getElementById('cityCharId');
  const bearDesc=document.getElementById('bearDesc');
  const bearKST=document.getElementById('bearKST');
  const bearUTC=document.getElementById('bearUTC');
  const cityNameField=document.getElementById('cityNameField');
  const cityIdField=document.getElementById('cityIdField');
  const bearDescField=document.getElementById('bearDescField');
  const bearKSTField=document.getElementById('bearKSTField');
  const bearUTCField=document.getElementById('bearUTCField');
  const nameOnlyField=document.getElementById('nameOnlyField');
  const nameOnlyText=document.getElementById('nameOnlyText');
  const selInfo=document.getElementById('selInfo');

  const TYPE_BY_SIZE={
    1:[{v:'banner', name:'깃발'}],
    2:[{v:'city', name:'도시'},{v:'ally_res', name:'연맹자원'}],
    3:[{v:'bear1',name:'곰사냥터1'},{v:'bear2',name:'곰사냥터2'},{v:'ally_hq',name:'연맹본부'}],
    12:[{v:'castle',name:'캐슬'}],
  };
  let mode='select', size=1, type='banner';

  modeSeg.addEventListener('change',()=>{ mode=radioVal('mode'); scheduleDraw(); });
  sizeSeg.addEventListener('change',()=>{ size=+radioVal('size'); renderTypeSeg(); scheduleDraw(); });
  typeSeg.addEventListener('change',()=>{ type=radioVal('otype'); updatePropForm(); scheduleDraw(); });

  function renderTypeSeg(){
    const list=TYPE_BY_SIZE[size]||[];
    typeSeg.innerHTML=list.map((t,i)=>`<label><input type="radio" name="otype" value="${t.v}" ${i===0?'checked':''}><span>${t.name}</span></label>`).join('');
    type=list[0]?.v??null; updatePropForm();
  }
  renderTypeSeg();

  function updatePropForm(){
    const cur = selectedId ? objects.get(selectedId)?.type : type;
    const isCity = cur==='city';
    const isBear = (cur==='bear1' || cur==='bear2');

    propTitle.textContent = isCity ? '도시 속성' : isBear ? '곰 사냥터 속성' : '속성';
    cityNameField.style.display = isCity ? 'flex' : 'none';
    cityIdField.style.display   = isCity ? 'flex' : 'none';
    bearDescField.style.display = isBear ? 'flex' : 'none';
    bearKSTField.style.display  = isBear ? 'flex' : 'none';
    bearUTCField.style.display  = isBear ? 'flex' : 'none';
    nameOnlyField.style.display = (!isCity && !isBear) ? 'flex' : 'none';
    nameOnlyText.textContent = typeName(cur);

    if (selectedId){
      const o=objects.get(selectedId);
      if (o?.type==='city'){ cityCharName.value=o.charName||''; cityCharId.value=o.charId||''; }
      if (o && (o.type==='bear1' || o.type==='bear2')){
        bearDesc.value=o.desc||''; bearKST.value=o.kst||''; bearUTC.value=o.utc||''; }
      const raw = `선택: #${o.id} (${typeName(o.type)}, ${o.size}×${o.size})`;
      selInfo.textContent = raw.length > 50 ? raw.slice(0,49) + '…' : raw;
    } else {
      if (isCity){ cityCharName.value=''; cityCharId.value=''; }
      if (isBear){ bearDesc.value=''; bearKST.value=''; bearUTC.value=''; }
      selInfo.textContent='(선택 없음)';
    }
  }

  // 도시 속성 실시간 반영
  cityCharName.addEventListener('input', () => {
    if (!selectedId) return;
    const o = objects.get(selectedId);
    if (o && o.type === 'city') { o.charName = cityCharName.value; scheduleDraw(); }
  });
  cityCharId.addEventListener('input', () => {
    if (!selectedId) return;
    const o = objects.get(selectedId);
    if (o && o.type === 'city') { o.charId = cityCharId.value; scheduleDraw(); }
  });

  // 저장/불러오기
  const STORAGE_KEY='iso-grid-builder:placements';
  const $ = (id)=>document.getElementById(id);
  function serialize(){
    return JSON.stringify({
      version:8,
      objects:[...objects.values()].map(o=>({
        id:o.id,x:o.x,y:o.y,size:o.size,type:o.type,
        charName:o.charName||null,charId:o.charId||null,
        desc:o.desc||null,kst:o.kst||null,utc:o.utc||null
      }))
    },null,2);
  }
  function clearGrid(){ for(let r=0;r<ROWS;r++) cells[r].fill(0); objects.clear(); selectedId=0; }
  function hydrate(json){
    clearGrid(); let data; try{ data=typeof json==='string'?JSON.parse(json):json; }catch{ alert('JSON 파싱 오류'); return; }
    if(!data||!Array.isArray(data.objects)){ alert('형식 오류'); return; }
    data.objects.forEach(raw=>{
      const id=raw.id??nextId++;
      const o={ id,
        x:raw.x|0,y:raw.y|0,size:raw.size|0,type:String(raw.type),
        charName:raw.charName||'', charId:raw.charId||'',
        desc:raw.desc||'', kst:raw.kst||'', utc:raw.utc||'' };
      objects.set(id,o);
      for(let j=0;j<o.size;j++) for(let i=0;i<o.size;i++) if (inBounds(o.x+i,o.y+j)) cells[o.y+j][o.x+i]=id;
      nextId=Math.max(nextId,id+1);
    });
    scheduleDraw();
  }
  $('saveLocal').addEventListener('click',()=>{ localStorage.setItem(STORAGE_KEY, serialize()); alert('배치를 저장했습니다.'); });
  $('loadLocal').addEventListener('click',()=>{ const s=localStorage.getItem(STORAGE_KEY); if(!s) return alert('저장된 배치 없음'); hydrate(s); });
  $('exportJson').addEventListener('click',()=>{
    let name = prompt('저장할 파일 이름을 입력하세요 (예: placements.json)', 'placements.json');
    if (!name) return;
    if (!name.toLowerCase().endsWith('.json')) name += '.json';
    const blob=new Blob([serialize()],{type:'application/json'});
    const a=document.createElement('a'); a.href=URL.createObjectURL(blob); a.download=name; document.body.appendChild(a); a.click(); a.remove();
  });
  $('importFile').addEventListener('change',async (e)=>{ const f=e.target.files?.[0]; if(!f) return; const txt=await f.text(); hydrate(txt); e.target.value=''; });
  // 모바일 메뉴와 동기화
  $('m_saveLocal').addEventListener('click',()=>$('saveLocal').click());
  $('m_loadLocal').addEventListener('click',()=>$('loadLocal').click());
  $('m_exportJson').addEventListener('click',()=>$('exportJson').click());
  $('m_importFile').addEventListener('change',async (e)=>{ const f=e.target.files?.[0]; if(!f) return; const txt=await f.text(); hydrate(txt); e.target.value=''; });

  // 배치/삭제
  function canPlace(x,y,s){
    if(x<0||y<0||x+s>COLS||y+s>ROWS) return false;
    for(let j=0;j<s;j++) for(let i=0;i<s;i++) if(cells[y+j][x+i]) return false;
    return true;
  }
  function canPlaceExcept(id,x,y,s){
    if(x<0||y<0||x+s>COLS||y+s>ROWS) return false;
    for(let j=0;j<s;j++){ for(let i=0;i<s;i++){ const hit=cells[y+j][x+i]; if(hit && hit!==id) return false; } }
    return true;
  }
  function occupy(o, id){ for(let j=0;j<o.size;j++) for(let i=0;i<o.size;i++) if (inBounds(o.x+i,o.y+j)) cells[o.y+j][o.x+i]=id; }
  function clearOccupy(o){ for(let j=0;j<o.size;j++) for(let i=0;i<s;i++){} } // placeholder to avoid accidental copy errors
  function clearOccupy(o){ for(let j=0;j<o.size;j++) for(let i=0;i<o.size;i++) if (inBounds(o.x+i,o.y+j)) cells[o.y+j][o.x+i]=0; }
  function place(x,y,s,t){
    if(!t||!canPlace(x,y,s)) return false;
    const id=nextId++, o={id,x,y,size:s,type:t};
    if(t==='city'){ o.charName=(cityCharName.value||'').trim(); o.charId=(cityCharId.value||'').trim(); }
    if(t==='bear1'||t==='bear2'){ o.desc=(bearDesc.value||'').trim(); o.kst=(bearKST.value||'').trim(); o.utc=(bearUTC.value||'').trim(); }
    objects.set(id,o); occupy(o,id); selectedId=id; updatePropForm(); return true;
  }
  function eraseObject(id){ const o=objects.get(id); if(!o) return; clearOccupy(o); objects.delete(id); }

  // 텍스트 폭 캐시
  const textWidthCache = new Map();
  function cachedTextWidth(s){
    const key = ctx.font + '|' + s;
    if (textWidthCache.has(key)) return textWidthCache.get(key);
    const w = ctx.measureText(s).width;
    textWidthCache.set(key, w);
    return w;
  }

  // 그리기 헬퍼
  function diamond(x,y,fill,stroke){
    const gw=GRID_W(), gh=GRID_H();
    ctx.beginPath();
    ctx.moveTo(x,y); ctx.lineTo(x+gw,y+gh); ctx.lineTo(x,y+2*gh); ctx.lineTo(x-gw,y+gh); ctx.closePath();
    if(fill){ ctx.fillStyle=fill; ctx.fill(); } if(stroke){ ctx.strokeStyle=stroke; ctx.lineWidth=1; ctx.stroke(); }
  }
  function blockVerts(x,y,s,pad){ return { top:gridToScreen(x+pad,y+pad), right:gridToScreen(x+s-pad,y+pad), bottom:gridToScreen(x+s-pad,y+s-pad), left:gridToScreen(x+pad,y+s-pad) }; }
  function drawBlockOutline(x,y,s,color,width=2,pad=OUTLINE_PAD){
    const v=blockVerts(x,y,s,pad);
    ctx.save(); ctx.beginPath();
    ctx.moveTo(v.top.x,v.top.y); ctx.lineTo(v.right.x,v.right.y); ctx.lineTo(v.bottom.x,v.bottom.y); ctx.lineTo(v.left.x,v.left.y); ctx.closePath();
    ctx.strokeStyle=color; ctx.lineWidth=width; ctx.stroke(); ctx.restore();
  }
  function drawBannerRadius(cx,cy,r){
    const s=2*r+1, v=blockVerts(cx-r,cy-r,s,0);
    ctx.save(); ctx.beginPath();
    ctx.moveTo(v.top.x,v.top.y); ctx.lineTo(v.right.x,v.right.y); ctx.lineTo(v.bottom.x,v.bottom.y); ctx.lineTo(v.left.x,v.left.y); ctx.closePath();
    ctx.fillStyle='rgba(0,102,255,0.10)'; ctx.fill();
    ctx.setLineDash([6,4]); ctx.strokeStyle='#66a3ff'; ctx.lineWidth=2; ctx.stroke(); ctx.setLineDash([]);
    ctx.restore();
  }
  function drawHQRadius(o){
    const startX=o.x-HQ_R, startY=o.y-HQ_R, total=o.size+HQ_R*2;
    const v=blockVerts(startX,startY,total,0);
    ctx.save(); ctx.beginPath();
    ctx.moveTo(v.top.x,v.top.y); ctx.lineTo(v.right.x,v.right.y); ctx.lineTo(v.bottom.x,v.bottom.y); ctx.lineTo(v.left.x,v.left.y); ctx.closePath();
    ctx.fillStyle='rgba(136,68,255,0.12)'; ctx.fill();
    ctx.setLineDash([8,6]); ctx.strokeStyle='#b290ff'; ctx.lineWidth=2; ctx.stroke(); ctx.setLineDash([]);
    ctx.restore();
  }
  function drawCastleRadius(o){
    const startX=o.x-CASTLE_R, startY=o.y-CASTLE_R, total=o.size+CASTLE_R*2;
    const v=blockVerts(startX,startY,total,0);
    ctx.save(); ctx.beginPath();
    ctx.moveTo(v.top.x,v.top.y); ctx.lineTo(v.right.x,v.right.y); ctx.lineTo(v.bottom.x,v.bottom.y); ctx.lineTo(v.left.x,v.left.y); ctx.closePath();
    ctx.fillStyle='rgba(255,64,64,0.15)'; ctx.fill();
    ctx.setLineDash([10,6]); ctx.strokeStyle='#ff6b6b'; ctx.lineWidth=2; ctx.stroke(); ctx.setLineDash([]);
    ctx.restore();
  }
  function fillObjectArea(o){
    const v=blockVerts(o.x,o.y,o.size,OBJECT_PAD);
    ctx.save(); ctx.beginPath();
    ctx.moveTo(v.top.x,v.top.y); ctx.lineTo(v.right.x,v.right.y); ctx.lineTo(v.bottom.x,v.bottom.y); ctx.lineTo(v.left.x,v.left.y); ctx.closePath();
    const fill=({banner:'#6ea8ffcc',city:'#8bd17fcc',ally_res:'#b392f0cc',bear1:'#ffaf5fcc',bear2:'#ffcf6fcc',ally_hq:'#ff6b6bcc',castle:'#ff4d4dcc'})[o.type]||'#6ea8ffcc';
    ctx.fillStyle=fill; ctx.fill();
    ctx.strokeStyle='#1c243fdd'; ctx.lineWidth=1.2; ctx.stroke();
    ctx.restore();
  }
  function drawTextCenter(lines, center){
    // scale: 0.30 ~ 2.0 → 폰트 px: 8 ~ 14 로 더 작게 맵핑
    const minPx = 8, maxPx = 14;
    const t = Math.max(0, Math.min(1, (scale - 0.30) / (2.0 - 0.30)));
    const clamped = Math.round(minPx + (maxPx - minPx) * t);
  
    // 줄간격: 거의 글자 크기와 동일하게 (여백 0 느낌)
    // 캔버스에서 실제 글자 높이 측정이 어려워 clamped에 아주 약간만 여유(클리핑 방지)
    const lineH = Math.ceil(clamped * 1.02); // 최소 여유(≈2%)
  
    ctx.save();
  
    // 폰트 설정(폭 계산 전에 반드시 설정)
    ctx.font = `600 ${clamped}px/1.0 "Nanum Gothic","Noto Sans KR",system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif`;
  
    // 폭 측정 (현재 폰트 기준)
    const widths = lines.map(t => cachedTextWidth(t)); // cachedTextWidth는 ctx.font을 키에 포함하는 구현이어야 정확
    const boxW   = Math.max(1, Math.max(...widths));   // 여백 0 → 패딩 없음
    const boxH   = Math.max(1, lines.length * lineH);  // 여백 0 → 패딩 없음
  
    // 중앙 정렬 기준으로 배경 박스 좌표 계산
    const bx = Math.round(center.x - boxW / 2);
    const by = Math.round(center.y - boxH / 2);
  
    // 배경(여백 0, 테두리 없음)
    ctx.fillStyle = 'rgba(7,12,26,0.5)';
    ctx.fillRect(bx, by, boxW, boxH);
  
    // 텍스트 그리기(외곽선 얇게 유지)
    ctx.textAlign    = 'center';
    ctx.textBaseline = 'middle';
    const doStroke   = clamped >= 12;
    ctx.lineWidth    = doStroke ? 1 : 0;
    ctx.strokeStyle  = 'rgba(0,0,0,0.85)';
    ctx.fillStyle    = '#ffffff';
  
    // 각 줄의 y 위치 (중앙 기준, 여백 0)
    for (let i = 0; i < lines.length; i++){
      const y = Math.round(center.y - (lines.length - 1) * lineH / 2 + i * lineH);
      const x = Math.round(center.x); // 서브픽셀 방지(스냅)
      const text = lines[i];
      if (doStroke) ctx.strokeText(text, x, y);
      ctx.fillText(text, x, y);
    }
  
    ctx.restore();
  }
  function drawCenterX(o){
    const v=blockVerts(o.x,o.y,o.size,OBJECT_PAD);
    ctx.save(); ctx.strokeStyle='#ffffff'; ctx.lineWidth=2;
    ctx.beginPath(); ctx.moveTo(v.top.x,v.top.y); ctx.lineTo(v.bottom.x,v.bottom.y);
    ctx.moveTo(v.left.x,v.left.y); ctx.lineTo(v.right.x,v.right.y); ctx.stroke(); ctx.restore();
  }

  // 화면 보이는 범위만 격자 렌더
  function drawGridVisible(){
    const rect = canvas.getBoundingClientRect();
    const w = Math.max(1, rect.width);
    const h = Math.max(1, rect.height);
    const corners = [[0,0],[w,0],[0,h],[w,h]];
    const gxList=[], gyList=[];
    for(const [sx,sy] of corners){ const p=screenToGrid(sx,sy); gxList.push(p.gx); gyList.push(p.gy); }
    const pad=3;
    let minGX=Math.max(0, Math.floor(Math.min(...gxList))-pad);
    let maxGX=Math.min(COLS-1, Math.ceil(Math.max(...gxList))+pad);
    let minGY=Math.max(0, Math.floor(Math.min(...gyList))-pad);
    let maxGY=Math.min(ROWS-1, Math.ceil(Math.max(...gyList))+pad);

    const tileA=css('--tile-a'), tileB=css('--tile-b');
    for(let gy=minGY; gy<=maxGY; gy++){
      for(let gx=minGX; gx<=maxGX; gx++){
        const p=gridToScreen(gx,gy);
        diamond(p.x,p.y, ((gx+gy)&1)?tileB:tileA, '#00000014');
      }
    }
  }

  // 항상 텍스트/영역 표시
  function draw(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    drawGridVisible();

    const arr=[...objects.values()].sort((a,b)=>a.y-b.y||a.x-b.x);

    // 타일 하이라이트(옅게)
    arr.forEach(o=>{
      for(let j=0;j<o.size;j++) for(let i=0;i<o.size;i++){
        const p=gridToScreen(o.x+i,o.y+j);
        diamond(p.x,p.y,'#94a3b824', null);
      }
    });

    // 반경/본체/외곽
    arr.forEach(o=>{
      if (o.type==='banner') drawBannerRadius(o.x,o.y,BANNER_R);
      if (o.type==='ally_hq') drawHQRadius(o);
      if (o.type==='castle') drawCastleRadius(o);
      fillObjectArea(o);
      const baseW = 1.2;
      const selW  = 2.2;
      drawBlockOutline(o.x,o.y,o.size,'#ffe28a', baseW, OUTLINE_PAD);
      if (o.id===selectedId)
        drawBlockOutline(o.x,o.y,o.size,'#ffd166', selW, OUTLINE_PAD);
    });

    // 라벨(항상)
    arr.forEach(o=>{
      const center=gridToScreen(o.x+o.size/2, o.y+o.size/2);
      if (o.type==='city' && o.charName) drawTextCenter([o.charName], center);
      if ((o.type==='bear1'||o.type==='bear2') && (o.desc||o.kst||o.utc)){
        const lines=[ o.desc || (o.type==='bear1'?'곰사냥터1':'곰사냥터2'),
                      ...(o.kst? [`KST ${o.kst}`] : []),
                      ...(o.utc? [`UTC ${o.utc}`] : []) ];
        drawTextCenter(lines, center);
      }
      if (o.type==='ally_res'){ drawCenterX(o); drawTextCenter(['연맹자원'], center); }
      if (o.type==='ally_hq'){ drawTextCenter(['본부'], center); }
      if (o.type==='castle'){ drawTextCenter(['캐슬'], center); }
    });

    // 프리뷰
    if (draggingObjId){
      const o=objects.get(draggingObjId);
      drawPreview(
        o.size, dragLastPos.gx, dragLastPos.gy,
        canPlaceExcept(draggingObjId, dragLastPos.gx, dragLastPos.gy, o.size),
        o.type
      );
    }
    if (placingDrag){
      const {size,type,cur}=placingDrag;
      drawPreview(size, cur.gx, cur.gy, canPlace(cur.gx,cur.gy,size), type);
    }
  }

  function drawPreview(size, gx, gy, ok, t){
    const color=ok?'rgba(82,210,115,.35)':'rgba(255,107,107,.35)';
    const stroke=ok?'#2c7a45':'#8a2c2c';
    for(let j=0;j<size;j++) for(let i=0;i<size;i++){ const p=gridToScreen(gx+i,gy+j); diamond(p.x,p.y,color, stroke); }
    if (t==='ally_hq'){ drawHQRadius({x:gx,y:gy,size}); }
    else if (t==='castle'){ drawCastleRadius({x:gx,y:gy,size}); }
    else if (t==='banner'){ drawBannerRadius(gx,gy,BANNER_R); }
  }

  let needsDraw=false;
  function scheduleDraw(){ if(needsDraw) return; needsDraw=true; requestAnimationFrame(()=>{ needsDraw=false; draw(); }); }

  // 안전한 사이즈 적용(초기 레이아웃 이후 실행)
  function applySize(){
    const rect = canvas.getBoundingClientRect();
    let w = Math.floor(rect.width), h = Math.floor(rect.height);
    if (w < 2 || h < 2){
      w = Math.max(2, window.innerWidth);
      h = Math.max(2, window.innerHeight);
    }
    canvas.width = w * DPR;
    canvas.height = h * DPR;
    ctx.setTransform(DPR,0,0,DPR,0,0);
    if(originX===0) originX = w/2;
    scheduleDraw();
  }

  // 이벤트 바인딩
  new ResizeObserver(()=>applySize()).observe(document.body);
  window.addEventListener('resize', applySize);
  window.addEventListener('orientationchange', ()=>{ setTimeout(applySize, 200); });

  canvas.addEventListener('contextmenu',e=>e.preventDefault());
  canvas.addEventListener('wheel',(e)=>{
    e.preventDefault();
    const r = interactionRect || canvas.getBoundingClientRect();
    zoomAt(e.deltaY, e.clientX, e.clientY, r);
  },{passive:false});

  function updatePointerMap(e, add){
    const rect=interactionRect || canvas.getBoundingClientRect();
    if(add){ activePointers.set(e.pointerId, {x:e.clientX-rect.left, y:e.clientY-rect.top}); }
    else   { activePointers.delete(e.pointerId); }
  }
  function currentPinchInfo(){
    const vals=[...activePointers.values()];
    if(vals.length<2) return null;
    const [p1,p2]=vals, dx=p2.x-p1.x, dy=p2.y-p1.y;
    return {dist:Math.hypot(dx,dy), cx:(p1.x+p2.x)/2, cy:(p1.y+p2.y)/2};
  }
  function zoomAt(delta,cx,cy, rectOpt){
    const rect = rectOpt || canvas.getBoundingClientRect();
    const before=screenToGrid(cx-rect.left, cy-rect.top);
    const prev=scale; scale=clamp(scale*(delta>0?1-ZOOM_STEP:1+ZOOM_STEP), ZOOM_MIN, ZOOM_MAX);
    if(prev===scale) return;
    const after=gridToScreen(before.gx,before.gy);
    originX+=cx-rect.left-after.x; originY+=cy-rect.top-after.y;
    scheduleDraw();
  }

  canvas.addEventListener('pointerdown',(e)=>{
    canvas.setPointerCapture(e.pointerId);
    // 이 시점의 rect 고정(폼 높이 변화로 인한 좌표 흔들림 방지)
    interactionRect = canvas.getBoundingClientRect();
    updatePointerMap(e,true);

    const {sx, sy, rect} = getLocalXY(e);
    const {gx,gy}=screenToGrid(sx,sy);
    const gridX=Math.floor(gx), gridY=Math.floor(gy);
    const hit=cells[gridY]?.[gridX]||0;
    const m=radioVal('mode');

    const pinch=currentPinchInfo();
    if(pinch && activePointers.size===2){
      pinchStartDist=pinch.dist; pinchStartScale=scale; pinchCenterScreen={x:pinch.cx+rect.left,y:pinch.cy+rect.top};
      isPanning=false; draggingObjId=0; placingDrag=null;
      isErasing=false; lastErasedCell=null;
      return;
    }

    // 우클릭 즉시 지우기
    if(e.button===2){
      if(hit) eraseObject(hit);
      if(selectedId===hit) selectedId=0;
      isErasing=false; lastErasedCell=null;
      updatePropForm(); scheduleDraw(); return;
    }

    if(m==='erase'){
      if(hit) eraseObject(hit);
      if(selectedId===hit) selectedId=0;
      isErasing = true;
      lastErasedCell = { x: gridX, y: gridY };
      updatePropForm(); scheduleDraw();
      return;
    }

    if(m==='build'){
      if(!placingDrag){
        placingDrag={ size:+radioVal('size')||1, type:radioVal('otype'), start:{gx:gridX, gy:gridY}, cur:{gx:gridX, gy:gridY} };
        scheduleDraw();
      }
      return;
    }

    if(m==='select'){
      if(hit){
        selectedId=hit; const o=objects.get(hit);
        dragObjOffset.dx = gridX - o.x; dragObjOffset.dy = gridY - o.y;
        dragLastPos.gx = o.x; dragLastPos.gy = o.y;
        draggingObjId = hit; updatePropForm(); scheduleDraw();
      }else{
        isPanning=true; panStart={x:e.clientX,y:e.clientY}; originStart={x:originX,y:originY};
      }
    }
  });

  canvas.addEventListener('pointermove',(e)=>{
    if(!activePointers.has(e.pointerId)) return;
    const {sx, sy, rect} = getLocalXY(e);
    updatePointerMap(e,true);

    const pinch=currentPinchInfo();
    if(pinch && activePointers.size===2){
      const scaleFactor = pinch.dist / (pinchStartDist||pinch.dist);
      const newScale = clamp(pinchStartScale * scaleFactor, ZOOM_MIN, ZOOM_MAX);
      const before = screenToGrid(pinchCenterScreen.x-rect.left, pinchCenterScreen.y-rect.top);
      scale = newScale;
      const after  = gridToScreen(before.gx, before.gy);
      originX += pinchCenterScreen.x-rect.left - after.x;
      originY += pinchCenterScreen.y-rect.top  - after.y;
      scheduleDraw(); return;
    }

    // 지우개 드래그
    if(isErasing && radioVal('mode')==='erase'){
      const p=screenToGrid(sx,sy);
      const gx=Math.floor(p.gx), gy=Math.floor(p.gy);
      if(gx!==lastErasedCell?.x || gy!==lastErasedCell?.y){
        const hit=cells[gy]?.[gx]||0;
        if(hit) { eraseObject(hit); scheduleDraw(); }
        lastErasedCell={x:gx,y:gy};
      }
      return;
    }

    if(placingDrag){
      const p=screenToGrid(sx,sy);
      placingDrag.cur.gx=Math.floor(p.gx);
      placingDrag.cur.gy=Math.floor(p.gy);
      scheduleDraw(); return;
    }

    if(draggingObjId){
      const p=screenToGrid(sx,sy);
      dragLastPos.gx=Math.floor(p.gx)-dragObjOffset.dx;
      dragLastPos.gy=Math.floor(p.gy)-dragObjOffset.dy;
      scheduleDraw(); return;
    }

    if(isPanning && panStart && originStart){
      originX=originStart.x+(e.clientX-panStart.x);
      originY=originStart.y+(e.clientY-panStart.y);
      scheduleDraw();
    }
  });

  canvas.addEventListener('pointerup',(e)=>{
    canvas.releasePointerCapture(e.pointerId);
    updatePointerMap(e,false);
    if(activePointers.size<=1) pinchStartDist=0;
    // 상호작용 종료 시 rect 해제
    interactionRect=null;

    if(isErasing){
      isErasing=false;
      lastErasedCell=null;
      return;
    }

    if(placingDrag){
      const {size,type,cur}=placingDrag;
      place(cur.gx,cur.gy,size,type);
      placingDrag=null; scheduleDraw(); return;
    }

    if(draggingObjId){
      const o=objects.get(draggingObjId);
      if(o && canPlaceExcept(o.id, dragLastPos.gx, dragLastPos.gy, o.size)){
        clearOccupy(o); o.x=dragLastPos.gx; o.y=dragLastPos.gy; occupy(o,o.id);
      }
      draggingObjId=0; scheduleDraw(); return;
    }

    isPanning=false; panStart=null; originStart=null;
  });

  canvas.addEventListener('pointercancel',()=>{
    draggingObjId=0; isPanning=false; panStart=null; originStart=null; pinchStartDist=0; placingDrag=null;
    interactionRect=null;
  });

  // 초기화
  function initAfterLayout(){
    applySize();
    originX = canvas.getBoundingClientRect().width / 2;
    scheduleDraw();
  }
  window.addEventListener('load', ()=> requestAnimationFrame(initAfterLayout));

  document.addEventListener('click', (e) => {
    document.querySelectorAll('details.menu[open]').forEach(d => {
      if (!d.contains(e.target)) d.removeAttribute('open');
    });
  });
})();
</script>
</body>
</html>
